import{T as U,H as w,r as g,a as G,A as c,C as b,L as l,b as V,c as q,N as v,d as W,e as S,K as P,f as O,g as $,h as Q,F as E,i as B,j,P as L,E as Z,k as Y,l as z,m as J,n as h,o as X,R as tt,p as f,q as N,Q as et,s as nt,t as at,u as F,S as st,v as rt,w as it,x as ot,y as ct,z as C}from"./index-226fb2d0.js";import{Y as pt,Z as It,_ as xt,$ as vt,a0 as Pt,a1 as Ct,a2 as Nt,a3 as Dt,a4 as Ht,a5 as Ft,G as Et,I as Bt,J as Rt,D as Kt,W as Mt,a6 as qt,a7 as Wt,a8 as jt,a9 as Lt,aa as zt,ab as Qt,ac as Ut,ad as Gt,ae as Vt,af as Ot,ag as $t,ah as Zt,ai as Yt,aj as Jt,ak as Xt,al as te,am as ee,B as ne,ao as ae,ap as se,an as re,aq as ie,ar as oe,as as ce,at as ue,au as le,av as he,aw as de,ax as fe,ay as me,M as _e,az as ge,V as be,bs as ye,aA as we,aB as Te,aC as ke,aD as Ae,aE as Se,X as pe,aF as Ie,aG as xe,bq as ve,aH as Pe,aI as Ce,br as Ne,O as De,U as He,aJ as Fe,aK as Ee,aL as Be,aM as Re,aN as Ke,aO as Me,aP as qe,aQ as We,bp as je,aR as Le,aS as ze,aT as Qe,aU as Ue,aV as Ge,aW as Ve,aX as Oe,aY as $e,aZ as Ze,a_ as Ye,a$ as Je,b0 as Xe,b1 as tn,b2 as en,b3 as nn,b4 as an,b5 as sn,b6 as rn,b7 as on,b8 as cn,b9 as un,ba as ln,bb as hn,bc as dn,bd as fn,be as mn,bf as _n,bg as gn,bh as bn,bi as yn,bj as wn,bk as Tn,bl as kn,bm as An,bn as Sn,bo as pn}from"./index-226fb2d0.js";class ft extends U{constructor(t={}){super(),this._hbarAllowances=t.hbarAllowances!=null?t.hbarAllowances:[],this._tokenAllowances=t.tokenAllowances!=null?t.tokenAllowances:[],this._nftAllowances=t.nftAllowances!=null?t.nftAllowances:[]}get hbarAllowances(){return this._hbarAllowances}addHbarAllowance(t,e){const n=e instanceof w?e:new w(e);return this._adjustHbarAllowance(null,t,g(n))}_adjustHbarAllowance(t,e,n){return this._requireNotFrozen(),this._hbarAllowances.push(new G({spenderAccountId:typeof e=="string"?c.fromString(e):e instanceof b?c.fromEvmAddress(0,0,e.toSolidityAddress()):e,ownerAccountId:typeof t=="string"?c.fromString(t):t instanceof b?c.fromEvmAddress(0,0,t.toSolidityAddress()):t,amount:n})),this}grantHbarAllowance(t,e,n){const a=n instanceof w?n:new w(n);return this._adjustHbarAllowance(t,e,g(a))}revokeHbarAllowance(t,e,n){const a=n instanceof w?n:new w(n);return this._adjustHbarAllowance(t,e,g(a).negated())}get tokenAllowances(){return this._tokenAllowances}addTokenAllowance(t,e,n){return this._adjustTokenAllowance(t,null,e,g(l.fromValue(n)))}_adjustTokenAllowance(t,e,n,a){return this._requireNotFrozen(),this._tokenAllowances.push(new V({tokenId:typeof t=="string"?q.fromString(t):t,spenderAccountId:typeof n=="string"?c.fromString(n):n instanceof b?c.fromEvmAddress(0,0,n.toSolidityAddress()):n,ownerAccountId:typeof e=="string"?c.fromString(e):e instanceof b?c.fromEvmAddress(0,0,e.toSolidityAddress()):e,amount:typeof a=="number"?l.fromNumber(a):a})),this}grantTokenAllowance(t,e,n,a){return this._adjustTokenAllowance(t,e,n,g(l.fromValue(a)))}revokeTokenAllowance(t,e,n,a){return this._adjustTokenAllowance(t,e,n,g(l.fromValue(a)))}addTokenNftAllowance(t,e){const n=typeof t=="string"?v.fromString(t):t;return this._adjustTokenNftAllowance(n,null,e)}_adjustTokenNftAllowance(t,e,n){this._requireNotFrozen();const a=typeof n=="string"?c.fromString(n):n instanceof b?c.fromEvmAddress(0,0,n.toSolidityAddress()):n,s=typeof e=="string"?c.fromString(e):e instanceof b?c.fromEvmAddress(0,0,e.toSolidityAddress()):e;let o=!1;for(const r of this._nftAllowances)if(r.tokenId.compare(t.tokenId)===0&&r.spenderAccountId!=null&&r.spenderAccountId.compare(a)===0){r.serialNumbers!=null&&r.serialNumbers.push(t.serial),o=!0;break}return o||this._nftAllowances.push(new W({tokenId:t.tokenId,spenderAccountId:a,serialNumbers:[t.serial],ownerAccountId:s,allSerials:!1,delegatingSpender:null})),this}grantTokenNftAllowance(t,e,n){const a=typeof t=="string"?v.fromString(t):t;return g(a.serial),this._adjustTokenNftAllowance(a,e,n)}revokeTokenNftAllowance(t,e,n){const a=typeof t=="string"?v.fromString(t):t;return g(a.serial),this._adjustTokenNftAllowance(new v(a.tokenId,a.serial.negate()),e,n)}addAllTokenNftAllowance(t,e){return this._adjustTokenNftAllowanceAllSerials(t,null,e,!0)}grantTokenNftAllowanceAllSerials(t,e,n){return this._adjustTokenNftAllowanceAllSerials(t,e,n,!0)}revokeTokenNftAllowanceAllSerials(t,e,n){return this._adjustTokenNftAllowanceAllSerials(t,e,n,!1)}_adjustTokenNftAllowanceAllSerials(t,e,n,a){return this._requireNotFrozen(),this._nftAllowances.push(new W({tokenId:typeof t=="string"?q.fromString(t):t,ownerAccountId:e!=null?typeof e=="string"?c.fromString(e):e instanceof b?c.fromEvmAddress(0,0,e.toSolidityAddress()):e:null,spenderAccountId:typeof n=="string"?c.fromString(n):n instanceof b?c.fromEvmAddress(0,0,n.toSolidityAddress()):n,serialNumbers:null,allSerials:a,delegatingSpender:null})),this}_validateChecksums(t){this._hbarAllowances.map(e=>e._validateChecksums(t)),this._tokenAllowances.map(e=>e._validateChecksums(t)),this._nftAllowances.map(e=>e._validateChecksums(t))}_execute(t,e){return Promise.reject(new Error("This feature has been deprecated for this class."))}_getTransactionDataCase(){throw new Error("This feature has been deprecated for this class.")}_makeTransactionData(){throw new Error("This feature has been deprecated.")}_getLogId(){return`AccountAllowanceAdjustTransaction:${this._transactionIds.current.validStart.toString()}`}}class mt{static async verifySignature(t,e,n,a){const s=await new S().setAccountId(e).execute(t);return s.key instanceof P?!1:s.key.verify(n,a)}static async verifyTransaction(t,e,n){const a=await new S().setAccountId(e).execute(t);return a.key instanceof P?!1:a.key.verifyTransaction(n)}static async verifySignatureWithSigner(t,e,n,a){const s=await new S().setAccountId(e).executeWithSigner(t);return s.key instanceof P?!1:s.key.verify(n,a)}static async verifyTransactionWithSigner(t,e,n){const a=await new S().setAccountId(e).executeWithSigner(t);return a.key instanceof P?!1:a.key.verifyTransaction(n)}}class _t{constructor(){this._bytecode=null,this._contractCreate=new O,this._signerPublicKeys=new Set,this._publicKeys=[],this._transactionSigners=[],this._maxChunks=null}get maxChunks(){return this._maxChunks}setMaxChunks(t){return this._maxChunks=t,this}get bytecode(){return this._bytecode}setBytecode(t){return this._bytecode=t instanceof Uint8Array?t:$(t),this}get adminKey(){return this._contractCreate.adminKey}setAdminKey(t){return this._contractCreate.setAdminKey(t),this}get gas(){return this._contractCreate.gas}setGas(t){return this._contractCreate.setGas(t),this}get initialBalance(){return this._contractCreate.initialBalance}setInitialBalance(t){return this._contractCreate.setInitialBalance(t),this}get proxyAccountId(){return this._contractCreate.proxyAccountId}setProxyAccountId(t){return this._contractCreate.setProxyAccountId(t),this}get autoRenewPeriod(){return this._contractCreate.autoRenewPeriod}setAutoRenewPeriod(t){return this._contractCreate.setAutoRenewPeriod(t),this}get constructorParameters(){return this._contractCreate.constructorParameters}setConstructorParameters(t){return this._contractCreate.setConstructorParameters(t),this}get contractMemo(){return this._contractCreate.contractMemo}setContractMemo(t){return this._contractCreate.setContractMemo(t),this}get maxAutomaticTokenAssociation(){return this._contractCreate.maxAutomaticTokenAssociations}setMaxAutomaticTokenAssociations(t){return this._contractCreate.setMaxAutomaticTokenAssociations(t),this}get stakedAccountId(){return this._contractCreate.stakedAccountId}setStakedAccountId(t){return this._contractCreate.setStakedAccountId(t),this}get stakedNodeId(){return this._contractCreate.stakedNodeId}setStakedNodeId(t){return this._contractCreate.setStakedNodeId(t),this}get declineStakingRewards(){return this._contractCreate.declineStakingRewards}setDeclineStakingReward(t){return this._contractCreate.setDeclineStakingReward(t),this}get autoRenewAccountId(){return this._contractCreate.autoRenewAccountId}setAutoRenewAccountId(t){return this._contractCreate.setAutoRenewAccountId(t),this}sign(t){return this.signWith(t.publicKey,e=>Promise.resolve(t.sign(e)))}signWith(t,e){const n=t.toBytesRaw(),a=Q(n);return this._signerPublicKeys.has(a)?this:(this._publicKeys.push(t),this._transactionSigners.push(e),this)}async execute(t,e){if(this._bytecode==null)throw new Error("cannot create contract with no bytecode");const n=t.operatorPublicKey,a=new E().setKeys(n!=null?[n]:[]).setContents(this._bytecode.subarray(0,Math.min(this._bytecode.length,2048))).freezeWith(t);await y(a,this._publicKeys,this._transactionSigners);let s=await a.execute(t,e);const r=(await s.getReceipt(t)).fileId;if(this._bytecode.length>2048){const i=new B().setFileId(r).setContents(this._bytecode.subarray(2048)).freezeWith(t);await y(i,this._publicKeys,this._transactionSigners),await i.execute(t,e)}if(this._contractCreate.setBytecodeFileId(r).freezeWith(t),await y(this._contractCreate,this._publicKeys,this._transactionSigners),s=await this._contractCreate.execute(t,e),await s.getReceipt(t),n!=null){const i=new j().setFileId(r).freezeWith(t);await y(i,this._publicKeys,this._transactionSigners),await(await i.execute(t,e)).getReceipt(t)}return s}async executeWithSigner(t){if(this._bytecode==null)throw new Error("cannot create contract with no bytecode");if(t.getAccountKey==null)throw new Error("`Signer.getAccountKey()` is not implemented, but is required for `ContractCreateFlow`");const e=await t.getAccountKey();let n;if(e instanceof L)n=e;else{const i=Object.values(e._key._key._keyData),T=new Uint8Array(i);n=L.fromBytes(T)}const a=await new E().setKeys(n!=null?[n]:[]).setContents(this._bytecode.subarray(0,Math.min(this._bytecode.length,2048))).freezeWithSigner(t);await a.signWithSigner(t),await y(a,this._publicKeys,this._transactionSigners);let s=await a.executeWithSigner(t);const r=(await s.getReceiptWithSigner(t)).fileId;if(this._bytecode.length>2048){let i=new B().setFileId(r).setContents(this._bytecode.subarray(2048));this._maxChunks!=null&&i.setMaxChunks(this._maxChunks),i=await i.freezeWithSigner(t),await i.signWithSigner(t),await y(i,this._publicKeys,this._transactionSigners),await i.executeWithSigner(t)}if(this._contractCreate=await this._contractCreate.setBytecodeFileId(r).freezeWithSigner(t),this._contractCreate=await this._contractCreate.signWithSigner(t),await y(this._contractCreate,this._publicKeys,this._transactionSigners),s=await this._contractCreate.executeWithSigner(t),await s.getReceiptWithSigner(t),e!=null){const i=await new j().setFileId(r).freezeWithSigner(t);await i.signWithSigner(t),await y(i,this._publicKeys,this._transactionSigners),await(await i.executeWithSigner(t)).getReceiptWithSigner(t)}return s}}async function y(d,t,e){for(let n=0;n<t.length;n++)await d.signWith(t[n],e[n])}class gt{constructor(t={}){this._ethereumData=null,this._callDataFileId=null,this._maxGasAllowance=null,t.ethereumData!=null&&this.setEthereumData(t.ethereumData),t.maxGasAllowance!=null&&this.setMaxGasAllowanceHbar(t.maxGasAllowance),this._maxChunks=null}get maxChunks(){return this._maxChunks}setMaxChunks(t){return this._maxChunks=t,this}get ethereumData(){return this._ethereumData}setEthereumData(t){return this._ethereumData=t instanceof Uint8Array?Z.fromBytes(t):t,this}get maxGasAllowance(){return this._maxGasAllowance}setMaxGasAllowance(t){return this.setMaxGasAllowanceHbar(t)}setMaxGasAllowanceHbar(t){return this._maxGasAllowance=t instanceof w?t:new w(t),this}async execute(t){if(this._ethereumData==null)throw new Error("cannot submit ethereum transaction with no ethereum data");const e=new Y,n=this._ethereumData.toBytes();if(this._maxGasAllowance!=null&&e.setMaxGasAllowanceHbar(this._maxGasAllowance),this._callDataFileId!=null){if(this._ethereumData.callData.length===0)throw new Error("call data file ID provided, but ethereum data already contains call data");e.setEthereumData(n).setCallDataFileId(this._callDataFileId)}else if(n.length<=5120)e.setEthereumData(n);else{const a=await ut(this._ethereumData.callData,t,this._maxChunks);this._ethereumData.callData=new Uint8Array,e.setEthereumData(this._ethereumData.toBytes()).setCallDataFileId(a)}return e.execute(t)}}async function ut(d,t,e){const n=Q(d),a=(await(await new E().setContents(n.substring(0,4096)).setKeys(t.operatorPublicKey?[t.operatorPublicKey]:[]).execute(t)).getReceipt(t)).fileId;if(d.length>4096){let s=new B().setFileId(a).setContents(n.substring(4096,n.length));e!=null&&s.setMaxChunks(e),await(await s.execute(t)).getReceipt(t)}return a}const{proto:lt}=J;class R{constructor(t){this.currentRate=t.currentRate,this.nextRate=t.nextRate,Object.freeze(this)}static _fromProtobuf(t){return new R({currentRate:z._fromProtobuf(t.currentRate),nextRate:z._fromProtobuf(t.nextRate)})}_toProtobuf(){return{currentRate:this.currentRate._toProtobuf(),nextRate:this.nextRate._toProtobuf()}}static fromBytes(t){return R._fromProtobuf(lt.ExchangeRateSet.decode(t))}}class A{constructor(t={}){this.min=t.min,this.max=t.max,this.constant=t.constant,this.transactionBandwidthByte=t.transactionBandwidthByte,this.transactionVerification=t.transactionVerification,this.transactionRamByteHour=t.transactionRamByteHour,this.transactionStorageByteHour=t.transactionStorageByteHour,this.contractTransactionGas=t.contractTransactionGas,this.transferVolumeHbar=t.transferVolumeHbar,this.responseMemoryByte=t.responseMemoryByte,this.responseDiskByte=t.responseDiskByte}static fromBytes(t){return A._fromProtobuf(h.proto.FeeComponents.decode(t))}static _fromProtobuf(t){return new A({min:t.min!=null?t.min:void 0,max:t.max!=null?t.max:void 0,constant:t.constant!=null?t.constant:void 0,transactionBandwidthByte:t.bpt!=null?t.bpt:void 0,transactionVerification:t.vpt!=null?t.vpt:void 0,transactionRamByteHour:t.rbh!=null?t.rbh:void 0,transactionStorageByteHour:t.sbh!=null?t.sbh:void 0,contractTransactionGas:t.gas!=null?t.gas:void 0,transferVolumeHbar:t.tv!=null?t.tv:void 0,responseMemoryByte:t.bpr!=null?t.bpr:void 0,responseDiskByte:t.sbpr!=null?t.sbpr:void 0})}_toProtobuf(){return{min:this.min!=null?this.min:void 0,max:this.max!=null?this.max:void 0,constant:this.constant!=null?this.constant:void 0,bpt:this.transactionBandwidthByte!=null?this.transactionBandwidthByte:void 0,vpt:this.transactionVerification!=null?this.transactionVerification:void 0,rbh:this.transactionRamByteHour!=null?this.transactionRamByteHour:void 0,sbh:this.transactionStorageByteHour!=null?this.transactionStorageByteHour:void 0,gas:this.contractTransactionGas!=null?this.contractTransactionGas:void 0,tv:this.transferVolumeHbar!=null?this.transferVolumeHbar:void 0,bpr:this.responseMemoryByte!=null?this.responseMemoryByte:void 0,sbpr:this.responseDiskByte!=null?this.responseDiskByte:void 0}}toBytes(){return h.proto.FeeComponents.encode(this._toProtobuf()).finish()}}class p{constructor(t={}){this.nodedata=t.nodedata,this.networkdata=t.networkdata,this.servicedata=t.servicedata,this.feeDataType=t.feeDataType}static fromBytes(t){return p._fromProtobuf(h.proto.FeeData.decode(t))}static _fromProtobuf(t){return new p({nodedata:t.nodedata!=null?A._fromProtobuf(t.nodedata):void 0,networkdata:t.networkdata!=null?A._fromProtobuf(t.networkdata):void 0,servicedata:t.servicedata!=null?A._fromProtobuf(t.servicedata):void 0,feeDataType:t.subType!=null?X._fromCode(t.subType):void 0})}_toProtobuf(){return{nodedata:this.nodedata!=null?this.nodedata._toProtobuf():void 0,networkdata:this.networkdata!=null?this.networkdata._toProtobuf():void 0,servicedata:this.servicedata!=null?this.servicedata._toProtobuf():void 0,subType:this.feeDataType!=null?this.feeDataType.valueOf():void 0}}toBytes(){return h.proto.FeeData.encode(this._toProtobuf()).finish()}}class D{constructor(t={}){this.hederaFunctionality=t.hederaFunctionality,this.feeData=t.feeData,this.fees=t.fees}static fromBytes(t){return D._fromProtobuf(h.proto.TransactionFeeSchedule.decode(t))}static _fromProtobuf(t){return new D({hederaFunctionality:t.hederaFunctionality!=null?tt._fromCode(t.hederaFunctionality):void 0,feeData:t.feeData!=null?p._fromProtobuf(t.feeData):void 0,fees:t.fees!=null?t.fees.map(e=>p._fromProtobuf(e)):void 0})}_toProtobuf(){return{hederaFunctionality:this.hederaFunctionality!=null?this.hederaFunctionality.valueOf():void 0,feeData:this.feeData!=null?this.feeData._toProtobuf():void 0,fees:this.fees!=null?this.fees.map(t=>t._toProtobuf()):void 0}}toBytes(){return h.proto.TransactionFeeSchedule.encode(this._toProtobuf()).finish()}}class I{constructor(t={}){this.transactionFeeSchedule=t.transactionFeeSchedule,this.expirationTime=t.expirationTime}static fromBytes(t){return I._fromProtobuf(h.proto.FeeSchedule.decode(t))}static _fromProtobuf(t){return new I({transactionFeeSchedule:t.transactionFeeSchedule!=null?t.transactionFeeSchedule.map(e=>D._fromProtobuf(e)):void 0,expirationTime:t.expiryTime!=null?f._fromProtobuf(t.expiryTime):void 0})}_toProtobuf(){return{transactionFeeSchedule:this.transactionFeeSchedule!=null?this.transactionFeeSchedule.map(t=>t._toProtobuf()):void 0,expiryTime:this.expirationTime!=null?this.expirationTime._toProtobuf():void 0}}toBytes(){return h.proto.FeeSchedule.encode(this._toProtobuf()).finish()}}class K{constructor(t={}){this.current=t.currentFeeSchedule,this.next=t.nextFeeSchedule}static fromBytes(t){return K._fromProtobuf(h.proto.CurrentAndNextFeeSchedule.decode(t))}static _fromProtobuf(t){return new K({currentFeeSchedule:t.currentFeeSchedule!=null?I._fromProtobuf(t.currentFeeSchedule):void 0,nextFeeSchedule:t.nextFeeSchedule!=null?I._fromProtobuf(t.nextFeeSchedule):void 0})}_toProtobuf(){return{currentFeeSchedule:this.current!=null?this.current._toProtobuf():void 0,nextFeeSchedule:this.next!=null?this.next._toProtobuf():void 0}}toBytes(){return h.proto.CurrentAndNextFeeSchedule.encode(this._toProtobuf()).finish()}}const bt={},yt={};class ht{constructor(){this._call=null}_setCall(t){this._call=t}unsubscribe(){this._call!=null&&this._call()}}class H{constructor(t){this.consensusTimestamp=t.consensusTimestamp,this.contents=t.contents,this.runningHash=t.runningHash,this.sequenceNumber=t.sequenceNumber,Object.freeze(this)}static _fromProtobuf(t){return new H({consensusTimestamp:f._fromProtobuf(t.consensusTimestamp),contents:t.message!=null?t.message:new Uint8Array,runningHash:t.runningHash!=null?t.runningHash:new Uint8Array,sequenceNumber:t.sequenceNumber!=null?t.sequenceNumber instanceof l?t.sequenceNumber:l.fromValue(t.sequenceNumber):l.ZERO})}_toProtobuf(){return{consensusTimestamp:this.consensusTimestamp._toProtobuf(),message:this.contents,runningHash:this.runningHash,sequenceNumber:this.sequenceNumber}}}class x{constructor(t){this.consensusTimestamp=t.consensusTimestamp,this.contents=t.contents,this.runningHash=t.runningHash,this.sequenceNumber=t.sequenceNumber,this.chunks=t.chunks,this.initialTransactionId=t.initialTransactionId,Object.freeze(this)}static _ofSingle(t){return new x({consensusTimestamp:f._fromProtobuf(t.consensusTimestamp),contents:t.message!=null?t.message:new Uint8Array,runningHash:t.runningHash!=null?t.runningHash:new Uint8Array,sequenceNumber:t.sequenceNumber!=null?t.sequenceNumber instanceof l?t.sequenceNumber:l.fromNumber(t.sequenceNumber):l.ZERO,initialTransactionId:t.chunkInfo!=null&&t.chunkInfo.initialTransactionID!=null?N._fromProtobuf(t.chunkInfo.initialTransactionID):null,chunks:[H._fromProtobuf(t)]})}static _ofMany(t){const e=t.length,n=t[e-1],a=f._fromProtobuf(n.consensusTimestamp),s=n.runningHash,o=n.sequenceNumber!=null?n.sequenceNumber instanceof l?n.sequenceNumber:l.fromValue(n.sequenceNumber):l.ZERO;t.sort((u,_)=>(u!=null&&u.chunkInfo!=null&&u.chunkInfo.number!=null?u.chunkInfo.number:0)<(_!=null&&_.chunkInfo!=null&&_.chunkInfo.number!=null?_.chunkInfo.number:0)?-1:1);const r=t.map(u=>H._fromProtobuf(u)),i=r.map(u=>u.contents.length).reduce((u,_)=>u+_,0),T=new Uint8Array(i);let k=0;t.forEach(u=>{T.set(u.message,k),k+=u.message.length});let m=null;return t.length>0&&t[0].chunkInfo!=null&&t[0].chunkInfo.initialTransactionID!=null&&(m=N._fromProtobuf(t[0].chunkInfo.initialTransactionID)),new x({consensusTimestamp:a,contents:T,runningHash:s,sequenceNumber:o,chunks:r,initialTransactionId:m})}}class wt extends et{constructor(t={}){super(),this._topicId=null,t.topicId!=null&&this.setTopicId(t.topicId),this._startTime=null,t.startTime!=null&&this.setStartTime(t.startTime),this._endTime=null,t.endTime!=null&&this.setEndTime(t.endTime),this._limit=null,t.limit!=null&&this.setLimit(t.limit),this._errorHandler=(e,n)=>{console.error(`Error attempting to subscribe to topic: ${this._topicId!=null?this._topicId.toString():""}`)},t.errorHandler!=null&&(this._errorHandler=t.errorHandler),this._listener=null,this._completionHandler=()=>{this._logger&&this._logger.info(`Subscription to topic ${this._topicId!=null?this._topicId.toString():""} complete`)},t.completionHandler!=null&&(this._completionHandler=t.completionHandler),this._retryHandler=e=>{if(e!=null){if(e instanceof Error)return!0;switch(e.code){case 13:return nt.test(e.details.toString());case 5:case 8:case 14:case 17:return!0;default:return!1}}return!1},t.retryHandler!=null&&(this._retryHandler=t.retryHandler),this._attempt=0,this._handle=null,this.setMaxBackoff(8e3)}get topicId(){return this._topicId}setTopicId(t){return this.requireNotSubscribed(),this._topicId=typeof t=="string"?at.fromString(t):t.clone(),this}get startTime(){return this._startTime}setStartTime(t){return this.requireNotSubscribed(),this._startTime=t instanceof f?t:t instanceof Date?f.fromDate(t):new f(t,0),this}get endTime(){return this._endTime}setEndTime(t){return this.requireNotSubscribed(),this._endTime=t instanceof f?t:t instanceof Date?f.fromDate(t):new f(t,0),this}get limit(){return this._limit}setLimit(t){return this.requireNotSubscribed(),this._limit=t instanceof l?t:l.fromValue(t),this}setErrorHandler(t){return this._errorHandler=t,this}setCompletionHandler(t){return this.requireNotSubscribed(),this._completionHandler=t,this}setMaxAttempts(t){return this.requireNotSubscribed(),this._maxAttempts=t,this}setMaxBackoff(t){return this.requireNotSubscribed(),this._maxBackoff=t,this}subscribe(t,e,n){return this._handle=new ht,this._listener=n,e!=null&&(this._errorHandler=e),this._makeServerStreamRequest(t),this._handle}_makeServerStreamRequest(t){const e=new Map,n=h.com.hedera.mirror.api.proto.ConsensusTopicQuery.encode({topicID:this._topicId!=null?this._topicId._toProtobuf():null,consensusStartTime:this._startTime!=null?this._startTime._toProtobuf():null,consensusEndTime:this._endTime!=null?this._endTime._toProtobuf():null,limit:this._limit}).finish(),a=t._mirrorNetwork.getNextMirrorNode().getChannel().makeServerStreamRequest("ConsensusService","subscribeTopic",n,s=>{const o=h.com.hedera.mirror.api.proto.ConsensusTopicResponse.decode(s);if(this._limit!=null&&this._limit.gt(0)&&(this._limit=this._limit.sub(1)),this._startTime=f._fromProtobuf(o.consensusTimestamp).plusNanos(1),o.chunkInfo==null||o.chunkInfo!=null&&o.chunkInfo.total===1)this._passTopicMessage(x._ofSingle(o));else{const r=o.chunkInfo,i=r.initialTransactionID,T=r.total,k=N._fromProtobuf(i).toString();let m=[];const u=e.get(k);if(u==null?e.set(k,m):m=u,m.push(o),m.length===T){const _=x._ofMany(m);e.delete(k),this._passTopicMessage(_)}}},s=>{const o=s instanceof Error?s.message:s.details;if(this._attempt<this._maxAttempts&&this._retryHandler(s)){const r=Math.min(250*2**this._attempt,this._maxBackoff);console.warn(`Error subscribing to topic ${this._topicId!=null?this._topicId.toString():"UNKNOWN"} during attempt ${this._attempt}. Waiting ${r} ms before next attempt: ${o}`),this._attempt+=1,setTimeout(()=>{this._makeServerStreamRequest(t)},r)}},this._completionHandler);this._handle!=null&&this._handle._setCall(()=>a())}requireNotSubscribed(){if(this._handle!=null)throw new Error("Cannot change fields on an already subscribed query")}_passTopicMessage(t){try{if(this._listener!=null)this._listener(t);else throw new Error("(BUG) listener is unexpectedly not set")}catch(e){this._errorHandler(t,e)}}}class M{constructor(t,e,n){const a=typeof e=="string"?F.fromString(e):e;this.publicKey=a.publicKey,this.signer=s=>Promise.resolve(a.sign(s)),this.provider=n,this.accountId=typeof t=="string"?c.fromString(t):t}static createRandomED25519(){const t=F.generateED25519(),n=t.publicKey.toAccountId(0,0);return Promise.resolve(new M(n,t))}static createRandomECDSA(){const t=F.generateECDSA(),n=t.publicKey.toAccountId(0,0);return Promise.resolve(new M(n,t))}getProvider(){return this.provider}getAccountId(){return this.accountId}getAccountKey(){return this.publicKey}getLedgerId(){return this.provider==null?null:this.provider.getLedgerId()}getNetwork(){return this.provider==null?{}:this.provider.getNetwork()}getMirrorNetwork(){return this.provider==null?[]:this.provider.getMirrorNetwork()}async sign(t){const e=[];for(const n of t)e.push(new st({publicKey:this.publicKey,signature:await this.signer(n),accountId:this.accountId}));return e}getAccountBalance(){return this.call(new rt().setAccountId(this.accountId))}getAccountInfo(){return this.call(new S().setAccountId(this.accountId))}getAccountRecords(){return this.call(new it().setAccountId(this.accountId))}signTransaction(t){return t.signWith(this.publicKey,this.signer)}checkTransaction(t){const e=t.transactionId;if(e!=null&&e.accountId!=null&&e.accountId.compare(this.accountId)!=0)throw new Error("transaction's ID constructed with a different account ID");if(this.provider==null)return Promise.resolve(t);const n=(t.nodeAccountIds!=null?t.nodeAccountIds:[]).map(s=>s.toString()),a=Object.values(this.provider.getNetwork()).map(s=>s.toString());if(!n.reduce((s,o)=>s&&a.includes(o),!0))throw new Error("Transaction already set node account IDs to values not within the current network");return Promise.resolve(t)}populateTransaction(t){if(t._freezeWithAccountId(this.accountId),t.transactionId==null&&t.setTransactionId(N.generate(this.accountId)),t.nodeAccountIds!=null&&t.nodeAccountIds.length!=0)return Promise.resolve(t.freeze());if(this.provider==null)return Promise.resolve(t);const e=Object.values(this.provider.getNetwork()).map(n=>typeof n=="string"?c.fromString(n):n);return ot(e),t.setNodeAccountIds(e.slice(0,(e.length+3-1)/3)),Promise.resolve(t.freeze())}call(t){if(this.provider==null)throw new Error("cannot send request with an wallet that doesn't contain a provider");return this.provider.call(t._setOperatorWith(this.accountId,this.publicKey,this.signer))}}class Tt{constructor(t){this._logger=ct({level:t.toString(),transport:{target:"pino-pretty",options:{translateTime:"SYS:dd-mm-yyyy HH:MM:ss",ignore:"pid,hostname"}}}),this._previousLevel=t}setLogger(t){return this._logger=t,this}setLevel(t){return this._previousLevel=C._fromString(this._logger.level),this._logger.level=t.toString(),this}get level(){return C._fromString(this._logger.level)}get levels(){return this._logger.levels.labels}setSilent(t){return t?this._logger.level=C.Silent.toString():this._logger.level=this._previousLevel.toString(),this}get silent(){return this._logger.level==C.Silent.toString()}trace(t){this._logger.trace(t)}debug(t){this._logger.debug(t)}info(t){this._logger.info(t)}warn(t){this._logger.warn(t)}error(t){this._logger.error(t)}fatal(t){this._logger.fatal(t)}}const kt={Mainnet:"mainnet",Testnet:"testnet",Previewnet:"previewnet"};export{ft as AccountAllowanceAdjustTransaction,pt as AccountAllowanceApproveTransaction,It as AccountAllowanceDeleteTransaction,xt as AccountBalance,rt as AccountBalanceQuery,vt as AccountCreateTransaction,Pt as AccountDeleteTransaction,c as AccountId,Ct as AccountInfo,mt as AccountInfoFlow,S as AccountInfoQuery,it as AccountRecordsQuery,Nt as AccountStakersQuery,Dt as AccountUpdateTransaction,Ht as AddressBookQuery,Ft as AssessedCustomFee,Et as BadKeyError,Bt as BadMnemonicError,Rt as BadMnemonicReason,Kt as Cache,Mt as Client,qt as ContractByteCodeQuery,Wt as ContractCallQuery,_t as ContractCreateFlow,O as ContractCreateTransaction,jt as ContractDeleteTransaction,Lt as ContractExecuteTransaction,zt as ContractFunctionParameters,Qt as ContractFunctionResult,Ut as ContractFunctionSelector,b as ContractId,Gt as ContractInfo,Vt as ContractInfoQuery,Ot as ContractLogInfo,$t as ContractNonceInfo,Zt as ContractUpdateTransaction,Yt as CustomFee,Jt as CustomFixedFee,Xt as CustomFractionalFee,te as CustomRoyaltyFee,ee as DelegateContractId,ne as EntityIdHelper,gt as EthereumFlow,Y as EthereumTransaction,Z as EthereumTransactionData,ae as EthereumTransactionDataEip1559,se as EthereumTransactionDataEip2930,re as EthereumTransactionDataLegacy,ie as EvmAddress,z as ExchangeRate,R as ExchangeRates,oe as Executable,ce as FeeAssessmentMethod,A as FeeComponents,p as FeeData,X as FeeDataType,I as FeeSchedule,K as FeeSchedules,B as FileAppendTransaction,ue as FileContentsQuery,E as FileCreateTransaction,j as FileDeleteTransaction,le as FileId,he as FileInfo,de as FileInfoQuery,fe as FileUpdateTransaction,me as FreezeTransaction,_e as HEDERA_PATH,w as Hbar,G as HbarAllowance,ge as HbarUnit,be as Key,P as KeyList,ye as LedgerId,we as LiveHash,Te as LiveHashAddTransaction,ke as LiveHashDeleteTransaction,Ae as LiveHashQuery,C as LogLevel,Tt as Logger,Se as MaxQueryPaymentExceeded,pe as Mnemonic,kt as NetworkName,Ie as NetworkVersionInfo,xe as NetworkVersionInfoQuery,v as NftId,ve as PrecheckStatusError,F as PrivateKey,Pe as PrngTransaction,bt as Provider,Ce as ProxyStaker,L as PublicKey,et as Query,Ne as ReceiptStatusError,tt as RequestType,De as SLIP44_ECDSA_ETH_PATH,He as SLIP44_ECDSA_HEDERA_PATH,Fe as ScheduleCreateTransaction,Ee as ScheduleDeleteTransaction,Be as ScheduleId,Re as ScheduleInfo,Ke as ScheduleInfoQuery,Me as ScheduleSignTransaction,qe as SemanticVersion,yt as Signer,st as SignerSignature,We as Status,je as StatusError,ht as SubscriptionHandle,Le as SystemDeleteTransaction,ze as SystemUndeleteTransaction,f as Timestamp,V as TokenAllowance,Qe as TokenAssociateTransaction,Ue as TokenBurnTransaction,Ge as TokenCreateTransaction,Ve as TokenDeleteTransaction,Oe as TokenDissociateTransaction,$e as TokenFeeScheduleUpdateTransaction,Ze as TokenFreezeTransaction,Ye as TokenGrantKycTransaction,q as TokenId,Je as TokenInfo,Xe as TokenInfoQuery,tn as TokenMintTransaction,W as TokenNftAllowance,en as TokenNftInfo,nn as TokenNftInfoQuery,an as TokenPauseTransaction,sn as TokenRevokeKycTransaction,rn as TokenSupplyType,on as TokenType,cn as TokenUnfreezeTransaction,un as TokenUnpauseTransaction,ln as TokenUpdateTransaction,hn as TokenWipeTransaction,dn as TopicCreateTransaction,fn as TopicDeleteTransaction,at as TopicId,mn as TopicInfo,_n as TopicInfoQuery,x as TopicMessage,H as TopicMessageChunk,wt as TopicMessageQuery,gn as TopicMessageSubmitTransaction,bn as TopicUpdateTransaction,U as Transaction,D as TransactionFeeSchedule,N as TransactionId,yn as TransactionReceipt,wn as TransactionReceiptQuery,Tn as TransactionRecord,kn as TransactionRecordQuery,An as TransactionResponse,Sn as Transfer,pn as TransferTransaction,M as Wallet};
